---
title: "Lab 4 Assignment - Landcover"
output:
  html_document:
    df_print: paged
---

```{r}
# Load your required R packages here.
require(Voss)
require(tidyverse)
require(terra)
require(FedData)
require(sf)
require(tidyterra)
require(landscapemetrics)
# require(PerformanceAnalytics)
```

## Challenge 1 (4 points)

**The landscapemetrics package has functions for calculating 12 patch-level metrics. Calculate all 12 of these for every forest patch in our nlcdSimple raster (using the 8-direction rule). This will result in 12 unique values associated with each forest patch. Use the chart.Correlation() function from the PerformanceAnalytics package to examine the correlation among all 12 of these variables. What patterns do you notice, and what do they tell you about the uniqueness or redundancy of the patch-level metrics you calculated?**

```{r}
studyArea = st_read('/vsicurl/https://github.com/ValenteJJ/SpatialEcology/raw/main/Week4/studyArea.shp')
nlcd = get_nlcd(studyArea, label='AlLandscape', year=2011)

# values(nlcd) = as.character(values(nlcd))

plot(nlcd)
nlcdSimple = nlcd
nlcdSimple[nlcdSimple==11] = 1 #Wet areas are a 1 now
nlcdSimple[nlcdSimple %in% c(21, 22, 23, 24)] = 2 #All developed areas are 2
nlcdSimple[nlcdSimple %in% c(31, 52)] = 3 #Barren land and shrub/scrub are 3
nlcdSimple[nlcdSimple %in% c(41,42,43)] = 4 #All forest types are 4
nlcdSimple[nlcdSimple == 71] = 5 #Grassland is 5
nlcdSimple[nlcdSimple %in% c(81,82)] = 6 #And agriculture is 6

#Give these numbers category names
tmp = data.frame('ID' = c(1, 2, 3, 4, 5, 6),
                 'category' = c('wetland', 'developed', 'open', 'forest', 'grassland', 'agriculture'))
nlcdSimple = categories(nlcdSimple, value=tmp)

#And plot the new raster
ggplot(nlcdSimple, aes(x=x, y=y, fill=category)) +
  geom_raster()+
  scale_fill_manual(values=c('blue', 'black', 'gray', 'darkolivegreen', 'orange', 'yellow'))

#simplify
forest = nlcdSimple %>% 
  setValues(NA)
forest[nlcdSimple ==4] = 1#where values in the nlcd raster=4(aka forest) should become a 1
plot(forest)

#Give the patches IDs
forestPatchId = patches(forest, directions=8, zeroAsNA=T, allowGaps=F)
plot(forestPatchId)


PatchArea = lsm_p_area(forest, directions=8)
PatchArea
PatchCoreAreaIndex = lsm_p_cai(forest, directions=8) 
PatchCoreAreaIndex
PatchCore = lsm_p_circle(forest, directions=8)
PatchCore
PatchContiguity = lsm_p_contig(forest, directions=8) 
PatchContiguity
PatchCoreArea = lsm_p_core(forest, directions=8) 
PatchCoreArea
PatchEnn = lsm_p_enn(forest, directions=8) 
PatchEnn
PatchFractal = lsm_p_frac(forest, directions=8) 
PatchFractal
PatchGyration = lsm_p_gyrate(forest, directions=8) 
PatchGyration
PatchNCore = lsm_p_ncore(forest, directions=8) 
PatchNCore
PatchPerimArea = lsm_p_para(forest, directions=8) 
PatchPerimArea
PatchPerimeter = lsm_p_perim(forest, directions=8) 
PatchPerimeter
PatchShape = lsm_p_shape(forest, directions=8)
PatchShape

BIG=rbind(PatchArea, PatchCoreAreaIndex, PatchCore, PatchContiguity, PatchCoreArea, PatchEnn, PatchFractal, PatchGyration, PatchNCore,PatchPerimArea, PatchPerimeter, PatchShape)
BIG2=pivot_wider(BIG, names_from=metric, values_from=value)
colnames(BIG2)
BIG3=BIG2 %>% select(area:shape)

PerformanceAnalytics::chart.Correlation (BIG3, histogram = TRUE, method = c("pearson"))
```
metrics dealing with area and perimeter such as perim, shape, area, and core are all very correlated. measures dealing with the shape, such as shape, perimiter, gyrate, frac, and contig are also very correlated to one another. some metrics such as contig and para are strongly negatively correlated. Para and enn have negative correlations to all other metrics except each other. This informs me that, while metrics may measure things in different ways and tell different aspects about the data, many overlap significantly in the core of their measurement/output.


____________________________________________________________________________________________________________________________


## Challenge 2 (4 points)

**In our lab, we used the 8-direction or "queen" rule to delineate patches. Using the nlcdSimple raster we created, explore the differences in patch characteristics if you were to use the 4-direction or "rook" rule for delineating patches. Calculate the following class-level metrics for forest cover for both the queen and rook patch delineation rules: _number of patches_, _mean patch size_, _standard deviation in patch size_, _nearest-neighbor distance_, and _total edge length_. What patterns do you notice? When might it be appropriate to use one rule vs. the other?**

``````{r}

forest = nlcdSimple %>% 
  setValues(NA)

forest[nlcdSimple ==4] = 1#where values in the nlcd raster=4(aka forest) should become a 1
plot(forestPatchId)
forestRook = patches(forest, directions=4, zeroAsNA=T, allowGaps=F)
plot(forestRook)#forest Rook

#not sure if this is what you mean by "explore the differences in patch characteristics if you were to use the 4-direction or "rook" rule for delineating patches" or if the next part is
PatchArea = lsm_p_area(forest, directions=4)
PatchArea
PatchCoreAreaIndex = lsm_p_cai(forest, directions=4) 
PatchCoreAreaIndex
PatchCore = lsm_p_circle(forest, directions=4)
PatchCore
PatchContiguity = lsm_p_contig(forest, directions=4) 
PatchContiguity
PatchCoreArea = lsm_p_core(forest, directions=4) 
PatchCoreArea
PatchEnn = lsm_p_enn(forest, directions=4) 
PatchEnn
PatchFractal = lsm_p_frac(forest, directions=4) 
PatchFractal
PatchGyration = lsm_p_gyrate(forest, directions=4) 
PatchGyration
PatchNCore = lsm_p_ncore(forest, directions=4) 
PatchNCore
PatchPerimArea = lsm_p_para(forest, directions=4) 
PatchPerimArea
PatchPerimeter = lsm_p_perim(forest, directions=4) 
PatchPerimeter
PatchShape = lsm_p_shape(forest, directions=4)
PatchShape



Queen = patches(forest, directions=8, zeroAsNA=T, allowGaps=F)#this is literally the same as forestpatchID, but Qenn had a hissy fit when I tried to simplify it, and im over it
  
  QnumP=get_patches(Queen) #number of patches; there are 49 patches
    QnumP
  QmeanPsize = (lsm_c_area_mn(forest, directions=8))#mean patch size
    QmeanPsize
  QsdevPsize = (lsm_c_area_sd(forest, directions= 8))#standard deviation in patch size
    QsdevPsize
  QEnn = lsm_p_enn(forest, directions=8)#nearest Neighbor distance
    QEnn
  QTotEL=lsm_c_ca(forest, directions=8) #total edge length
    QTotEL

Rook = patches(forest, directions=4, zeroAsNA=T, allowGaps=F)
 RnumP=get_patches(Rook) #number of patches; there are 67 patches
    RnumP
  RmeanPsize = (lsm_c_area_mn(forest, directions=4))#mean patch size
    RmeanPsize
  RsdevPsize = (lsm_c_area_sd(forest, directions=4))#standard deviation in patch size
    RsdevPsize
  REnn = lsm_p_enn(forest, directions=4)#nearest Neighbor distance
    REnn
  RTotEL=lsm_c_ca(forest, directions=4) #total edge length
    RTotEL
```


  the standard deviation and mean area are smaller for the Rook than the queen;the nearest neighbor distance changed in two instances on the Rook. the total edge length did not change. the number of patches increased for the Rook to 67 (Queen was 49)
Queen would be most appropriate for species that are more mobile, as it looks at patches on the diagonal(ie, only touches the main patch in a corner). the Rook would be best used for species that are less mobile.




_____________________________________________________________________________________________________________________________


## Challenge 3 (4 points)

**Using the same zoomed-in study area that we used in the lab, download NLCD raster data for the years 2001 and 2019 and simplify these rasters into 6 landcover categories (wet, developed, barren, forest, grassland, and agriculture). Plot these two rasters. What are some of the initial changes you notice between 2001 and 2019?**
```{r}
studyArea = st_read('/vsicurl/https://github.com/ValenteJJ/SpatialEcology/raw/main/Week4/studyArea.shp')

nlcd2001 = get_nlcd(studyArea, label='AlLandscape', year=2001)
#simplify
  nlcd2001[nlcd2001==11] = 1 #Wet areas are a 1 now
  nlcd2001[nlcd2001 %in% c(21, 22, 23, 24)] = 2 #All developed areas are 2
  nlcd2001[nlcd2001 %in% c(31, 52)] = 3 #Barren land and shrub/scrub are 3
  nlcd2001[nlcd2001 %in% c(41,42,43)] = 4 #All forest types are 4
  nlcd2001[nlcd2001 == 71] = 5 #Grassland is 5
  nlcd2001[nlcd2001 %in% c(81,82)] = 6 #And agriculture is 6
#Give numbers category names
  tmp2001 = data.frame('ID' = c(1, 2, 3, 4, 5, 6),
                   'category' = c('wet', 'developed', 'barren', 'forest', 'grassland', 'agriculture'))
  nlcd2001 = categories(nlcd2001, value=tmp2001)
#plot new raster
  ggplot(nlcd2001, aes(x=x, y=y, fill=category)) +
    geom_raster()+
    scale_fill_manual(values=c('blue', 'black', 'gray', 'darkolivegreen', 'orange', 'yellow'))

  
nlcd2019 = get_nlcd(studyArea, label='AlLandscape', year=2019)
#simplify
  nlcd2019[nlcd2019==11] = 1 #Wet areas are a 1 now
  nlcd2019[nlcd2019 %in% c(21, 22, 23, 24)] = 2 #All developed areas are 2
  nlcd2019[nlcd2019 %in% c(31, 52)] = 3 #Barren land and shrub/scrub are 3
  nlcd2019[nlcd2019 %in% c(41,42,43)] = 4 #All forest types are 4
  nlcd2019[nlcd2019 == 71] = 5 #Grassland is 5
  nlcd2019[nlcd2019 %in% c(81,82)] = 6 #And agriculture is 6
#Give numbers category names
tmp2019 = data.frame('ID' = c(1, 2, 3, 4, 5, 6),
                 'category' = c('wet', 'developed', 'barren', 'forest', 'grassland', 'agriculture'))
nlcd2019 = categories(nlcd2019, value=tmp2019)

#plot new raster
ggplot(nlcd2019, aes(x=x, y=y, fill=category)) +
  geom_raster()+
  scale_fill_manual(values=c('blue', 'black', 'gray', 'darkolivegreen', 'orange', 'yellow'))
```
  looks like the amount of evergreen and deciduous forest has decreased and been replaced by grasses, shrubs, and crops. 


**Quantify this at the class level by calculating and reporting the changes in (1) the total amount of each land cover type (2) mean patch size for each land cover type, and (3) mean nearest neighbor distance for each cover type between the years 2011 and 2019. Give a short description of how you interpret the changes in these values.**

```{r}

classCats = data.frame('class' = c(1, 2, 3, 4, 5, 6),
                 'category' = c('wet', 'developed', 'barren', 'forest', 'grassland', 'agriculture'))

#2001
  landcoverT2001 = lsm_c_ca(nlcd2001) %>% 
  left_join(classCats, by='class')#total amount of each cover type
    landcoverT2001
  numP2001= lsm_c_area_mn(nlcd2001) %>% 
  left_join(classCats, by='class')#mean patch size for each cover type
    numP2001
  Enn2001 = lsm_c_enn_mn(nlcd2001) %>% 
  left_join(classCats, by='class')#nearest Neighbor distance for cover
    Enn2001
    


#2019
  landcoverT2019 = lsm_c_ca(nlcd2019) %>% 
  left_join(classCats, by='class')#total amount of each cover type
    landcoverT2019
  numP2019= lsm_c_area_mn(nlcd2019) %>% 
  left_join(classCats, by='class')#mean patch size for each cover type
    numP2019
  Enn2019 = lsm_c_enn_mn(nlcd2019) %>% 
  left_join(classCats, by='class')#nearest Neighbor distance for cover
    Enn2019
```
First, I make sure i am comparing 2001 to 2019 via listed order for each metric respectively(so make sure I am comparing 2001 total amount of cover(ca) values to 2019 ca values, 2001 mean patch area values within classes(area_mn) to 2019 area_mn, 2001 mean distance to nearest neighbor between patches within classes (enn_mn) to 2019 enn_mn values). comparing these respectively, I look at the values column to know covertype (ex: class 3 is Barren) and look at the associated value *(or be fancy and do code to make the categories to show up-classcats)*.
for example the total amount of Barren cover(3) increased from 22.32 hectares in 2001 to 181.71 hectares in 2019. this provides a quantitative change in the cover between years.



**Quantify these changes at the landscape level by calculating and reporting on changes in the (1) Shannon diversity and (2) Shannon evenness of the landscapes at the different time points. Give a short description of how you interpret the changes in these values.**

```{r}
#2001
  lsm_l_shdi(nlcd2001) #shannon diversity
  lsm_l_shei(nlcd2001) #shannon index
#2019
  lsm_l_shdi(nlcd2019) #shannon diversity
  lsm_l_shei(nlcd2019) #shannon index
```
in this instance, the Shannon's Diversity Index (SHDI) provides a number value that summarizes the cover diversity on our landscape takes into account the number of different classes(cover types) and their respective abundances. Where SHDI=0, there is only one patch present. the number increases (infinitely) as the number of classes increases and the proportions are equally distributed. since it can be infinite, it is necessary to have context for comparison: here, the SHDI is higher (1.34) in 2019 than in 2001 (0.95). since the number of classes is the same in both years, we know that the relative abundances of cover in 2019 is more even- likely due to the decrease in forest cover. since we have the same number of classes present, a SHEI would be more appropriate

The shannon's evenness index(SHEI) gives the ratio between SHDI and the SHDI theoretical max. The output value indicates the evenness of the class/cover distribution relative to one another. output values range from 0 to 1, where 1 is max evenness (equal abundance among cover types) and 0 is min evenness (one cover type is more abundant than the rest).
The SHEI was larger for 2019(.75) than 2001(.53), indicating that the cover in 2019 is more even than in 2001.





______________________________________________________________________________________________________________________________





## Challenge 4 (4 points)

**Use the voss2d() function to simulate a surface where g = 7 and H = 0.5. From that, create 9 'landscapes' with 10%, 20%, 30%, ..., 90% threshold values. The '1' values here can represent anything your imagination comes up with. It could be forest cover, cover of some other land cover type, bodies of water, temperatures above a threshold, etc. I suggest you set the seed for your simulation value so that you get the same outcome each time you run the code. Plot these landscapes and comment on what patterns you see changing as the value increases from a 10% cover to 90% cover.**

```{r}
set.seed(23)

vossModel = voss2d(g=7, H=0.5) #(g =how big landscape is, h=tells abt autocorrelation in the simulated values in landscape- larger h= more autocorrelation, smaller h=less autocorrelation more staticy )
vossModel = rast(vossModel$z)

# 10% cover
  threshold10 = quantile(as.matrix(vossModel), prob=0.1)
  voss10 = ifel(vossModel > threshold10, 0, 1)
      plot(voss10)
# 20% cover
  threshold20 = quantile(as.matrix(vossModel), prob=0.2)
  voss20 = ifel(vossModel > threshold20, 0, 1)
      plot(voss20)
# 30% cover
  threshold30 = quantile(as.matrix(vossModel), prob=0.3)
  voss30 = ifel(vossModel > threshold30, 0, 1)
      plot(voss30)
# 40% cover
  threshold40 = quantile(as.matrix(vossModel), prob=0.4)
  voss40 = ifel(vossModel > threshold40, 0, 1)
      plot(voss40)
# 50% cover
  threshold50 = quantile(as.matrix(vossModel), prob=0.5)
  voss50 = ifel(vossModel > threshold50, 0, 1)
      plot(voss50)
# 60% cover
  threshold60 = quantile(as.matrix(vossModel), prob=0.6)
  voss60 = ifel(vossModel > threshold60, 0, 1)
      plot(voss60)
# 70% cover
  threshold70 = quantile(as.matrix(vossModel), prob=0.7)
  voss70 = ifel(vossModel > threshold70, 0, 1)
      plot(voss70)
# 20% cover
  threshold80 = quantile(as.matrix(vossModel), prob=0.8)
  voss80 = ifel(vossModel > threshold80, 0, 1)
      plot(voss80)
# 30% cover
  threshold90 = quantile(as.matrix(vossModel), prob=0.9)
  voss90 = ifel(vossModel > threshold90, 0, 1)
      plot(voss90)
```
As the %cover increases, it fills up like flooding terrain. The water(green)fills low terrain up and the higher altitude terrain is preserved (white). As you increase the amount of water, the more terrain is progressively engulfed by water.


**Identify 3 class-level or landscape-level metrics that help you capture the changes you are observing. Calculate those metrics for each of the 9 landscapes and plot them (x-axis is threshold value and y-axis is calculated metric). Briefly describe why you chose these 3 metrics and how they change with increasing cover.**

```{r}
#10% cover
  TotAreaL10 = lsm_c_ca(voss10)
  coehesionC10 = lsm_c_cohesion(voss10)
  meancoreC10 = lsm_c_core_mn(voss10)
  
#20% cover
  TotAreaL20 = lsm_c_ca(voss20)
  TotAreaL20
  coehesionC20 = lsm_c_cohesion(voss20)
  coehesionC20
  meancoreC20 = lsm_c_core_mn(voss20)
  meancoreC20
#30% cover
  TotAreaL30 = lsm_c_ca(voss30)
  TotAreaL30
  coehesionC30 = lsm_c_cohesion(voss30)
  coehesionC30
  meancoreC30 = lsm_c_core_mn(voss30)
  meancoreC30
#40% cover
  TotAreaL40 = lsm_c_ca(voss40)
  TotAreaL40
  coehesionC40 = lsm_c_cohesion(voss40)
  coehesionC40
  meancoreC40 = lsm_c_core_mn(voss40)
  meancoreC40
#50% cover
  TotAreaL50 = lsm_c_ca(voss50)
  TotAreaL50
  coehesionC50 = lsm_c_cohesion(voss50)
  coehesionC50
  meancoreC50 = lsm_c_core_mn(voss50)
  meancoreC50
#60% cover
  TotAreaL60 = lsm_c_ca(voss60)
  TotAreaL60
  coehesionC60 = lsm_c_cohesion(voss60)
  coehesionC60
  meancoreC60 = lsm_c_core_mn(voss60)
  meancoreC60
#70% cover
  TotAreaL70 = lsm_c_ca(voss70)
  TotAreaL70
  coehesionC70 = lsm_c_cohesion(voss70)
  coehesionC70
  meancoreC70 = lsm_c_core_mn(voss70)
  meancoreC70
#80% cover
  TotAreaL80 = lsm_c_ca(voss80)
  TotAreaL80
  coehesionC80 = lsm_c_cohesion(voss80)
  coehesionC80
  meancoreC80 = lsm_c_core_mn(voss80)
  meancoreC80
#90% cover
  TotAreaL90 = lsm_c_ca(voss90)
  TotAreaL90
  coehesionC90 = lsm_c_cohesion(voss90)
  coehesionC90
  meancoreC90 = lsm_c_core_mn(voss90)
  meancoreC90
  
  

TotAreaClassD <- data.frame(
Threshold = c(0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9),
TotAreaclass= c(TotAreaL10, TotAreaL20, TotAreaL30,
                 TotAreaL40, TotAreaL50, TotAreaL60,
                 TotAreaL70, TotAreaL80, TotAreaL90)
)
classCoehesionD <- data.frame(
Threshold = c(0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9),
classCoehesion = c(coehesionC10, coehesionC20, coehesionC30,
                 coehesionC40, coehesionC50, coehesionC60,
                 coehesionC70, coehesionC80, coehesionC90)
  )
classMeanCoreD <- data.frame(
Threshold = c(0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9),
classMeanCore = c(meancoreC10, meancoreC20, meancoreC30,
                 meancoreC40, meancoreC50, meancoreC60,
                 meancoreC70, meancoreC80, meancoreC90)
)

# Plotting total area vs threshold
ggplot(TotAreaClassD, aes(x = Threshold, y = TotAreaclass)) +
  geom_point(color = "blue") +  # color for points
  labs(title = "Total Class Area vs Threshold Values",
       x = "Threshold ",
       y = "Total Area Landscape")

# Plotting cohesion vs threshold
ggplot(classCoehesionD, aes(x = Threshold, y = classCoehesion)) +
  geom_point(color = "red") + 
  labs(title = "Cohesion vs Threshold Values",
       x = "Threshold ",
       y = "Cohesion") 

# Plotting mean core vs threshold
ggplot(classMeanCoreD, aes(x = Threshold, y = classMeanCore)) +
  geom_point(color = "green") +
  labs(title = "Mean Core vs Threshold Values",
       x = "Threshold",
       y = "Mean Core") 

```

AREA_MN is an 'Area and Edge metric'. The metric summarises the landscape as the mean of all patch in the landscape. The metric is a simple way to describe the composition of the landscape. Especially together with the total landscape area (lsm_l_ta), it can also give an an idea of patch structure (e.g. many small patches vs. few larges patches).

COHESION is an 'Aggregation metric'. It characterises the connectedness of patches belonging to class i. It can be used to asses if patches of the same class are located aggregated or rather isolated and thereby COHESION gives information about the configuration of the landscape.

CORE_MN is a 'Core area metric' and equals the mean of core areas of all patches belonging to class i. The core area is defined as all cells that have no neighbor with a different value than themselves (rook's case)



____________________________________________________________________________________________________________________________


## Challenge 5 (4 points)

**Use the voss2d() function to simulate 9 surfaces. In each one, g should be 7, but vary the value of H from 0.1 to 0.9. Create a unique landscape from each of these with a threshold value of 30% cover. Again, the 1 values can represent anything you desire, and again I suggest you set the seed for your simulation value so that you get the same outcome each time you run the code. Plot these landscapes and comment on what patterns you see changing as the H value increases from 0.1 to 0.9.**

```{r}
set.seed(23)
vossModel1 = voss2d(g=7, H=0.1) #(g =how big landscape is, h=tells abt autocorrelation in the simulated values in landscape- larger h= more autocorrelation, smaller h=less autocorrelation more staticy )
vossModel1 = rast(vossModel1$z)
  plot(vossModel1)
vossModel2 = voss2d(g=7, H=0.2) 
vossModel2 = rast(vossModel2$z)
  plot(vossModel2)
vossModel3 = voss2d(g=7, H=0.3) 
vossModel3 = rast(vossModel3$z)
  plot(vossModel3)
vossModel4 = voss2d(g=7, H=0.4)
vossModel4 = rast(vossModel4$z)
  plot(vossModel4)
vossModel5 = voss2d(g=7, H=0.5) 
vossModel5 = rast(vossModel5$z)
  plot(vossModel5)
vossModel6 = voss2d(g=7, H=0.6) 
vossModel6 = rast(vossModel6$z) 
  plot(vossModel6)
vossModel7 = voss2d(g=7, H=0.7) 
vossModel7 = rast(vossModel7$z)
  plot(vossModel7)
vossModel8 = voss2d(g=7, H=0.8) 
vossModel8 = rast(vossModel8$z)
  plot(vossModel8)
vossModel9 = voss2d(g=7, H=0.9) 
vossModel9 = rast(vossModel9$z)
  plot(vossModel9)
```
it gets more fuzzy and less granular.



**Identify 3 class-level or landscape-level metrics that help you capture the changes you are observing. THESE MUST BE DIFFERENT THAN THOSE METRICS YOU USED IN CHALLENGE 2. Calculate those metrics for each of the 9 landscapes and plot them (x-axis is H-value and y-axis is calculated metric). Briefly describe why you chose these 3 metrics and how they change with increasing cover.**

```{r}
#vossModel1
  vossModel1enn = lsm_l_enn_mn(vossModel1)
PatchCohesion.1 <- vossModel1enn$value
  vossModel1enn
  vossModel1core = lsm_l_cohesion(vossModel1)
  vossModel1core
  vossModel1coehesion = lsm_c_core_mn(vossModel1)
  vossModel1coehesion
#vossModel12
  vossModel2enn = lsm_l_enn_mn(vossModel2)
  vossModel2enn
  vossModel2core = lsm_l_cohesion(vossModel2)
  vossModel2core
  vossModel2coehesion = lsm_c_core_mn(vossModel2)
  vossModel2coehesion
#vossModel3
  vossModel3enn = lsm_l_enn_mn(vossModel3)
  vossModel3enn
  vossModel3core = lsm_l_cohesion(vossModel3)
  vossModel3core
  vossModel3coehesion = lsm_c_core_mn(vossModel3)
  vossModel3coehesion
#vossModel4
  vossModel4enn = lsm_l_enn_mn(vossModel4)
  vossModel4enn
  vossModel4core = lsm_l_cohesion(vossModel4)
  vossModel4core
  vossModel4coehesion = lsm_c_core_mn(vossModel4)
  vossModel4coehesion
#vossModel5
  vossModel5enn = lsm_l_enn_mn(vossModel5)
  vossModel5enn
  vossModel5core = lsm_l_cohesion(vossModel5)
  vossModel5core
  vossModel5coehesion = lsm_c_core_mn(vossModel5)
  vossModel5coehesion
#vossModel6
  vossModel6enn = lsm_l_enn_mn(vossModel6)
  vossModel6enn
  vossModel6core = lsm_l_cohesion(vossModel6)
  vossModel6core
  vossModel6coehesion = lsm_c_core_mn(vossModel6)
  vossModel6coehesion
#vossModel7
  vossModel7enn = lsm_l_enn_mn(vossModel7)
  vossModel7enn
  vossModel7core = lsm_l_cohesion(vossModel7)
  vossModel7core
  vossModel7coehesion = lsm_c_core_mn(vossModel7)
  vossModel7coehesion
#vossModel8
  vossModel8enn = lsm_l_enn_mn(vossModel8)
  vossModel8enn
  vossModel8core = lsm_l_cohesion(vossModel8)
  vossModel8core
  vossModel8coehesion = lsm_c_core_mn(vossModel8)
  vossModel8coehesion
#vossModel9
  vossModel9enn = lsm_l_enn_mn(vossModel9)
  vossModel9enn
  vossModel9core = lsm_l_cohesion(vossModel9)
  vossModel9core
  vossModel9coehesion = lsm_c_core_mn(vossModel9)
  vossModel9coehesion
  
  
  
  
  # Data Frame to Plot
LandscapeCohesion <- data.frame(
  HValue = c(0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9),
  CohesionValues = c(PatchCohesion.1, PatchCohesion.2, PatchCohesion.3,
                 PatchCohesion.4, PatchCohesion.5, PatchCohesion.6,
                 PatchCohesion.7, PatchCohesion.8, PatchCohesion.9)
  
)
```

Place your text here.

